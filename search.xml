<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F09%2F27%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
  <entry>
    <title><![CDATA[神奇的bug]]></title>
    <url>%2F2018%2F11%2F29%2F%E7%A5%9E%E5%A5%87%E7%9A%84bug%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[23种设计模式（Java版）]]></title>
    <url>%2F2018%2F09%2F09%2F23%E7%A7%8D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%88Java%E7%89%88%EF%BC%89%2F</url>
    <content type="text"><![CDATA[设计模式的分类主要分为三大类：创建型模式，共五种：工厂方法模式，抽象工厂模式，单例模式，建造者模式，原型模式。结构型模式，共七种：适配器模式，装饰器模式，代理模式，外观模式，桥接模式，组合模式，享元模式。行为型模式，共十一种：策略模式，模板方法模式，观察者模式，迭代子模式，责任链模式，命令模式，备忘录模式，状态模式，访问者模式，中介者模式，解释器模式。还有两小类：并发行模式和线程池模式。 设计模式的六大原则总原则：开闭原则（Open CLose Principle)开闭原则就是说对扩展开放，对修改关闭。在程序需要进行拓展的时候，不能去修改原有的代码，而是要扩展原有代码，实现一个热插拔的效果。所以一句话概括就是：为了使程序的扩展性好，易于维护和升级。想要达到这样的效果，需要使用接口和抽象类等。 单一职责原则不要存在多于一个导致类变更的原因，也就是说每个类应该实现单一的职责，如若不然，就应该把类拆分。 里氏替换原则（Liskov Substitution Principle）里氏代换原则中说，任何基类可以出现的地方，子类一定可以出现。 LSP是继承复用的基石，只有当衍生类可以替换掉基类，软件单位的功能不受到影响时，基类才能真正被复用，而衍生类也能够在基类的基础上增加新的行为。里氏代换原则是对“开-闭”原则的补充。实现“开-闭”原则的关键步骤就是抽象化。而基类与子类的继承关系就是抽象化的具体实现，所以里氏代换原则是对实现抽象化的具体步骤的规范。里氏替换原则中，子类对父类的方法尽量不要重写和重载。因为父类代表了定义好的结构，通过这个规范的接口与外界交互，子类不应该随便破坏它。 依赖倒转原则（Dependence Inversion Principle）这个是开闭原则的基础，具体内容：面向接口编程，依赖于抽象而不依赖于具体。写代码时用到具体类时，不与具体类交互，而与具体类的上层接口交互。 接口隔离原则（Interface Segregation Principle）这个原则的意思是：每个接口中不存在子类用不到却必须实现的方法，如果不然，就要将接口拆分。使用多个隔离的接口，比使用单个接口（多个接口方法集合到一个的接口）要好。 迪米特法则（最少知道原则）（Demeter Principle）就是说：一个类对自己依赖的类知道的越少越好。也就是说无论被依赖的类多么复杂，都应该将逻辑封装在方法的内部，通过public方法提供给外部。这样当被依赖的类变化时，才能最小的影响该类。最少知道原则的另一个表达方式是：只与直接的朋友通信。类之间只要有耦合关系，就叫朋友关系。耦合分为依赖、关联、聚合、组合等。我们称出现为成员变量、方法参数、方法返回值中的类为直接朋友。局部变量、临时变量则不是直接的朋友。我们要求陌生的类不要作为局部变量出现在类中。 合成复用原则（Composite Reuse Principle）原则是尽量首先使用合成/聚合的方式，而不是使用继承。 Java的23种设计模式创建型模式—5种首先，简单工厂模式不属于23种设计模式，简单工厂一般分为：普通简单工厂、多方法简单工厂、静态方法简单工厂。 简单工厂模式(不属于23种设计模式，作为引入放在前面的位置)1.普通简单工厂模式就是建立一个工厂类，对实现了同一接口的一些类进行实例的创建。 工厂生产手机（实例） 先定义手机接口Mobile 123public interface Mobile &#123; public void call();&#125; 再定义具体产品–小米和魅族手机，它们都带有Mobile接口 123456public class MeiZu implements Mobile&#123; public void call() &#123; System.out.println("MeiZu手机"); &#125;&#125; 123456public class XiaoMi implements Mobile&#123; public void call() &#123; System.out.println("XiaoMi手机"); &#125;&#125; 再定义简单工厂类MobileFactory通过传入的参数来确定返回哪种手机的相关信息 1234567891011121314151617public class MobileFactory &#123; public Mobile getMobile (String title) throws Exception &#123; if(title.equalsIgnoreCase("xiaomi")) &#123; return new XiaoMi(); &#125; else if(title.equalsIgnoreCase("meizu")) &#123; return new MeiZu(); &#125; else &#123; throw new Exception("no such "+title+"mobile found"); &#125; &#125;&#125; 创建测试类test测试 1234567891011121314151617181920public class test &#123; public static void main(String[] args) &#123; // TODO Auto-generated method stub try &#123; MobileFactory mf = new MobileFactory(); Mobile m; m=mf.getMobile("xiaomi"); m.call(); m=mf.getMobile("meizu"); m.call(); &#125; catch(Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125; 2.多方法简单工厂模式是对普通工厂方法模式的改进，在普通工厂方法模式中，如果传递的字符串出错，则不能正确创建对象，而多个工厂方法模式是提供多个工厂方法，分别创建对象。只需要修改MobileFactory类就可以，如下： 12345678910public class MobileFactory&#123; public Mobile produceXiaoMi() &#123; return new XiaoMi(); &#125; pubilc Mobile produceMeiZu() &#123; return new MeiZu(); &#125;&#125; 测试类修改如下： 12345678910111213141516171819public class test &#123; public static void main(String[] args) &#123; // TODO Auto-generated method stub try &#123; MobileFactory mf = new MobileFactory(); Mobile m; m=mf.produceXiaoMi(); m.call(); m=mf.produceMeiZu(); m.call(); &#125; catch(Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125; 3.静态工厂方法模式将上面的多方法模式里的方法置为静态的，不需要创建实例，直接调用即可。总体来说，工厂模式适合：凡是出现了大量的产品需要创建，并且具有共同的接口时，可以通过工厂方法模式进行创建。在以上的三种模式中，第一种如果传入的字符串有误，不能正确创建对象，第三种相对于第二种，不需要实例化工厂类，所以，大多数情况下，我们会选用第三种——静态工厂方法模式。 1.工厂方法模式（Factory Method）简单工厂模式有一个问题就是，类的创建依赖工厂类，也就是说，如果想要拓展程序，必须对工厂类进行修改，这违背了闭包原则，所以，从设计角度考虑，有一定的问题，如何解决？就用到工厂方法模式，创建一个工厂接口和创建多个工厂实现类，这样一旦需要增加新的功能，直接增加新的工厂类就可以了，不需要修改之前的代码。 手机接口 1234public interface Mobile&#123; public void call();&#125; 手机工厂接口 1234public interface MobileFactory&#123; public Mobile produceMobile();&#125; 小米手机实现接口 1234567public class XiaoMi implements Mobile&#123; public void call() &#123; System.out.println("小米手机"); &#125;&#125; 魅族手机实现接口 1234567public class MeiZu implements Mobile&#123; public void call() &#123; System.out.println("魅族手机"); &#125;&#125; 小米手机工厂实现了生产手机的方法，返回小米手机 12345678public class XiaoMiFactory implements MobileFactory&#123; public Mobile produceMobile() &#123; System.out.println("小米手机的工厂制造了"); return new XiaoMi(); &#125;&#125; 魅族手机工厂实现了生产手机的方法，返回魅族手机 12345678public class MeiZuFactory implements MobileFactory&#123; public Mobile produceMobile() &#123; System.out.println("魅族手机的工厂制造了"); return new MeiZu(); &#125;&#125; 测试程序 1234567891011121314public class test&#123; public static void main(String argv[]) &#123; MobileFactory mf; Mobile m; mf = new XiaoMiFactory(); m = mf.produceMobile(); m.call(); mf = new MeiZuFactory(); m = mf.produceMobile(); m.call(); &#125;&#125; 如果我们想生产华为手机，只需新添华为手机工厂和华为手机实现接口即可。 2.抽象工厂模式抽象工厂即为扩展了的工厂，比如兵工厂生产两种产品，处了生产战斗机器，还训练驾驶机器的士兵，这种兵工厂就是抽象工厂了。Java实例–电脑产品：IBM,DELL都是著名的计算机生产厂家，他们采用的主板，硬盘，CPU是不相同的，但配件间，主板与CPU一定要相互兼容，IBM生产的所有配件为IBM的产品族，一个等级结构是由相同的结构产品组成，如IBM的CPU和DELL的CPU的产品等级相同。这种情况下就要用抽象工厂模式。 首先，定义CPU的接口： 1234public interface CPU&#123; public String getCPU();&#125; 定义AMD类，实现CPU接口： 1234567public class AMD implements CPU&#123; public String getCPU() &#123; return "Athlon XP 2800+"; &#125;&#125; 定义Intel类，实现CPU接口： 1234567public class Intel implements CPU&#123; public String getCPU() &#123; return "奔腾 4 3.2c"; &#125;&#125; 定义硬盘接口： 1234public interface HardDisk&#123; public String getSize();&#125; 定义Maxtor类，实现硬盘接口： 12345678910111213141516171819public class Maxtor implements HardDisk&#123; public String getSize() &#123; return "MaxLine Plus 200G"; &#125;&#125;``` + 定义WestDigit，实现硬盘接口：```javapublic class WestDigit implements HardDisk&#123; public String getSize() &#123; return "WD2500JD 250G"; &#125;&#125; 定义主板接口，包含参数为CPU的公共方法Attach(): 1234public interface MainBoard&#123; public void Attach (CPU cpu) throws Exception; &#125; 主板微星MSI865PE,支持Intel的CPU： 1234567891011121314public class MSI865PE implements MainBoard&#123; public void Attach(CPU cpu) throws Exception &#123; if(cpu.getClass().toString().endsWith("Intel")) &#123; System.out.println("MSI865PE"); &#125; else &#123; throw new Exception("主板MSI865PE只能配Intel的CPU"); &#125; &#125;&#125; 主板微星MSIK7N2G,支持AMD的CPU： 1234567891011121314public class MSIK7N2G implements MainBoard&#123; public void Attach(CPU cpu) throws Exception &#123; if(cpu.getClass().toString().endsWith("AMD")) &#123; System.out.println("MSIK7N2G"); &#125; else &#123; throw new Exception("主板MSIK7N2G只能配AMD的CPU"); &#125; &#125;&#125; 定义抽象电脑工厂类： 123456789101112131415161718192021public abstract class ComputerFactory&#123; CPU cpu; HardDisk hd; MainBoard mb; public void show() &#123; try &#123; System.out.println(this.getClass().getName().toString()+"生产的电脑配置"); System.out.println("CPU:"+cpu.getCPU()); System.out.println("HardDisk:"+hd.getSize()); System.out.println("MainBoard:"); mb.Attach(cpu); &#125; catch(Exception e) &#123; System.err.println(e.getMessage()); &#125; &#125;&#125; 抽象电脑工厂类派生类IBM,定义其返回的系列配件产品： 123456789public class IBM extends ComputerFactory&#123; IBM() &#123; cpu = new Intel(); hd = new WestDigit(); mb = new MSI865PE(); &#125;&#125; 抽象电脑工厂类派生类DELL,定义其返回的系列配件产品： 123456789public class DELL extends ComputerFactory&#123; IBM() &#123; cpu = new AMD(); hd = new Mator(); mb = new MSIK7N2G(); &#125;&#125; 测试程序： 12345678910public class test&#123; public static void main(String argv[]) &#123; IBM ibm = new IBM(); ibm.show(); DELL dell = new DELL(); dell.show(); &#125;&#125; 3.单例模式（Singleton）单例对象（Singleton）是一种常用的设计模式。在Java应用中，单例对象能保证在一个JVM中，该对象只有一个实例存在。这样的模式有几个好处： 某些类创建比较频繁，对于一些大型的对象，这是一笔很大的系统开销。 省去了new操作符，降低了系统内存的使用频率，减轻GC压力。 有些类如交易所的核心交易引擎，控制着交易流程，如果该类可以创建多个的话，系统完全乱了。（比如一个军队出现了多个司令员同时指挥，肯定会乱成一团），所以只有使用单例模式，才能保证核心交易服务器独立控制整个流程。例如现实中的单例模式Windows资源管理器，无论如何我们都不可能打开两个管理器，就是说，它在系统中只有单一的实例，同样系统日志也是单例模式，所有关联的日志都记录在同一个文件中。 4.建造者模式（Builder）现实中的例子，快餐店采用建造者模式构造儿童套餐，店内提供各种食品，但儿童套餐都一样，包括饮料，面包，薯条。儿童套餐就是建造者模式下的产品，包含构成产品的部件（饮料，面包，薯条）。员工小王就是具体的建造者，他装配儿童套餐中的各种食品，收银员就是指挥者，他指挥员工小王取哪一样食品，最后收银员返回一份完整的儿童套餐给客户。 java中建造房屋实例： 定义house接口： 123456public interface House&#123; boolean GetBackyard(); long NoOfRooms(); String Description();&#125; 定义Apartment公寓，有3间房间，没有后院： 1234567891011121314151617181920212223242526272829303132333435363738public class Apartment implements House&#123; private Boolean mblnBackyard; private Vector Rooms; public Apartment() &#123; Room room = new Room(); Rooms = new Vector(); room.RoomName = "Master Room"; Rooms.addElement(room); room = new Room(); room.RoomName = "Second Bedroom"; Rooms.addElement(room); room = new Room(); room.RoomName = "Living Room"; Rooms.addElement(room); mblnBackyard = false; &#125; public boolean GetBackyard() &#123; return mblnBackyard; &#125; public long NoOfRooms() &#123; return Rooms.size(); &#125; public String Description() &#123; String strDescription; strDescription = "这是一间公寓，有"+Rooms.size()+"间房间\n"; strDescription = strDescription + "这件公寓没有后院"； for(int i = 1 ;i &lt;= Rooms.size(); i++) &#123; strDescription = strDescription+"\n"+"房间"+i+"\t"+((Room)Rooms.elementAt(i-1)).RoomName; &#125; return strDescription; &#125;&#125; 定义家庭公寓，有5间房间，配有后院： 1234567891011121314151617181920212223242526272829303132333435363738394041424344public class Apartment implements House&#123; private Boolean mblnBackyard; private Vector Rooms; public Apartment() &#123; Room room = new Room(); Rooms = new Vector(); room.RoomName = "Master Room"; Rooms.addElement(room); room = new Room(); room.RoomName = "Second Bedroom"; Rooms.addElement(room); room = new Room(); room.RoomName = "Third Bedroom"; Rooms.addElement(room); room = new Room(); room.RoomName = "Guest Room"; Rooms.addElement(room); room = new Room(); room.RoomName = "Living Room"; Rooms.addElement(room); mblnBackyard = false; &#125; public boolean GetBackyard() &#123; return mblnBackyard; &#125; public long NoOfRooms() &#123; return Rooms.size(); &#125; public String Description() &#123; String strDescription; strDescription = "这是一间公寓，有"+Rooms.size()+"间房间\n"; strDescription = strDescription + "这件公寓有后院"； for(int i = 1 ;i &lt;= Rooms.size(); i++) &#123; strDescription = strDescription+"\n"+"房间"+i+"\t"+((Room)Rooms.elementAt(i-1)).RoomName; &#125; return strDescription; &#125;&#125; 房间类 1234public class Room&#123; public String RoomName;&#125; 指挥者类,指挥者通过传入的mblnBackyard参数的值，创建不同的House 1234567891011121314public class Director&#123; public House BuildHouse(boolean mblnBackyard) &#123; if(mblnBackyard) &#123; return new SingleFamilHome(); &#125; else &#123; return new Apartment(); &#125; &#125; &#125; 测试类，通过调用Director的BuildHouse方法建造房屋，传入参数决定房屋类型： 123456789public class test&#123; public static void main(String argv[]) &#123; Director director = new Director(); House house = director.BuildHouse(false); System.out.println(house.Description()); &#125;&#125; 5.原型模式（Prototype）原型模式指定创建对象的种类，并且通过拷贝这些原型创建新的对象。原型模式允许一个对象再创建另外一个可定制的对象，根本无需知道任何创建的细节。例如现实中的拷贝粘贴就是原型模式。 结构型模式—7种6.适配器模式适配器模式将某个类的接口转换成客户端期望的另一个接口表示，目的是消除由于接口不匹配所造成的类的兼容性问题。主要分为三类：类的适配器模式、对象的适配器模式、接口的适配器模式。 类的适配器模式核心思想就是：有一个Source类，拥有一个方法，待适配，目标接口是Targetable，通过Adapter类，将Source的功能扩展到Targetable里，看代码： 123456public class Source &#123; public void method1() &#123; System.out.println("this is original method!"); &#125; &#125; 12345678public interface Targetable &#123; /* 与原类中的方法相同 */ public void method1(); /* 新类的方法 */ public void method2(); &#125; 1234567public class Adapter extends Source implements Targetable &#123; @Override public void method2() &#123; System.out.println("this is the targetable method!"); &#125; &#125; Adapter类继承Source类，实现Targetable接口，下面是测试类：12345678public class AdapterTest &#123; public static void main(String[] args) &#123; Targetable target = new Adapter(); target.method1(); target.method2(); &#125; &#125; 输出：12this is original method!this is the targetable method! 这样Targetable接口的实现类就具有了Source类的功能。 对象的适配器模式基本思路和类的适配器模式相同，只是将Adapter类作修改，这次不继承Source类，而是持有Source类的实例，以达到解决兼容性的问题。只需要修改Adapter类的源码即可： 123456789101112131415161718public class Wrapper implements Targetable &#123; private Source source; public Wrapper(Source source)&#123; super(); this.source = source; &#125; @Override public void method2() &#123; System.out.println("this is the targetable method!"); &#125; @Override public void method1() &#123; source.method1(); &#125; &#125; 测试类： 123456789public class AdapterTest &#123; public static void main(String[] args) &#123; Source source = new Source(); Targetable target = new Wrapper(source); target.method1(); target.method2(); &#125; &#125; 接口的适配器模式第三种适配器模式是接口的适配器模式，接口的适配器是这样的：有时我们写的一个接口中有多个抽象方法，当我们写该接口的实现类时，必须实现该接口的所有方法，这明显有时比较浪费，因为并不是所有的方法都是我们需要的，有时只需要某一些，此处为了解决这个问题，我们引入了接口的适配器模式，借助于一个抽象类，该抽象类实现了该接口，实现了所有的方法，而我们不和原始的接口打交道，只和该抽象类取得联系，所以我们写一个类，继承该抽象类，重写我们需要的方法就行。这个很好理解，在实际开发中，我们也常会遇到这种接口中定义了太多的方法，以致于有时我们在一些实现类中并不是都需要。看代码： 12345public interface Sourceable &#123; public void method1(); public void method2(); &#125; 12345public abstract class Wrapper2 implements Sourceable&#123; public void method1()&#123;&#125; public void method2()&#123;&#125; &#125; 12345public class SourceSub1 extends Wrapper2 &#123; public void method1()&#123; System.out.println("the sourceable interface's first Sub1!"); &#125; &#125; 12345public class SourceSub2 extends Wrapper2 &#123; public void method2()&#123; System.out.println("the sourceable interface's second Sub2!"); &#125; &#125; 123456789101112public class WrapperTest &#123; public static void main(String[] args) &#123; Sourceable source1 = new SourceSub1(); Sourceable source2 = new SourceSub2(); source1.method1(); source1.method2(); source2.method1(); source2.method2(); &#125; &#125; 测试输出： 12the sourceable interface's first Sub1!the sourceable interface's second Sub2! 讲了这么多，总结一下三种适配器模式的应用场景： 类的适配器模式：当希望将一个类转换成满足另一个新接口的类时，可以使用类的适配器模式，创建一个新类，继承原有的类，实现新的接口即可。 对象的适配器模式：当希望将一个对象转换成满足另一个新接口的对象时，可以创建一个Wrapper类，持有原类的一个实例，在Wrapper类的方法中，调用实例的方法就行。 接口的适配器模式：当不希望实现一个接口中所有的方法时，可以创建一个抽象类Wrapper，实现所有方法，我们写别的类的时候，继承抽象类即可。 7.装饰模式（Decorator）顾名思义，装饰模式就是给一个对象增加一些新的功能，而且是动态的，要求装饰对象和被装饰对象实现同一个接口，装饰对象持有被装饰对象的实例，示例代码： Source类是被装饰类，Decorator类是一个装饰类，可以为Source类动态的添加一些功能 123public interface Sourceable &#123; public void method(); &#125; 1234567public class Source implements Sourceable &#123; @Override public void method() &#123; System.out.println("the original method!"); &#125; &#125; 123456789101112131415public class Decorator implements Sourceable &#123; private Sourceable source; public Decorator(Sourceable source)&#123; super(); this.source = source; &#125; @Override public void method() &#123; System.out.println("before decorator!"); source.method(); System.out.println("after decorator!"); &#125; &#125; 测试类: 12345678public class DecoratorTest &#123; public static void main(String[] args) &#123; Sourceable source = new Source(); Sourceable obj = new Decorator(source); obj.method(); &#125; &#125; 输出： 123before decorator!the original method!after decorator! 装饰器模式的应用场景： 1、需要扩展一个类的功能。 2、动态的为一个对象增加功能，而且还能动态撤销。（继承不能做到这一点，继承的功能是静态的，不能动态增删。） 缺点：产生过多相似的对象，不易排错！ 8.代理模式（Proxy）其实每个模式名称就表明了该模式的作用，代理模式就是多一个代理类出来，替原对象进行一些操作，比如我们在租房子的时候回去找中介，为什么呢？因为你对该地区房屋的信息掌握的不够全面，希望找一个更熟悉的人去帮你做，此处的代理就是这个意思。再如我们有的时候打官司，我们需要请律师，因为律师在法律方面有专长，可以替我们进行操作，表达我们的想法。 根据上文的阐述，代理模式就比较容易的理解了，我们看下代码： 123public interface Sourceable &#123; public void method(); &#125; 1234567public class Source implements Sourceable &#123; @Override public void method() &#123; System.out.println("the original method!"); &#125; &#125; 1234567891011121314151617181920public class Proxy implements Sourceable &#123; private Source source; public Proxy()&#123; super(); this.source = new Source(); &#125; @Override public void method() &#123; before(); source.method(); atfer(); &#125; private void atfer() &#123; System.out.println("after proxy!"); &#125; private void before() &#123; System.out.println("before proxy!"); &#125; &#125; 测试类： 12345678public class ProxyTest &#123; public static void main(String[] args) &#123; Sourceable source = new Proxy(); source.method(); &#125; &#125; 输出： 123before proxy!the original method!after proxy! 代理模式的应用场景： 如果已有的方法在使用的时候需要对原有的方法进行改进，此时有两种办法： 1、修改原有的方法来适应。这样违反了“对扩展开放，对修改关闭”的原则。 2、就是采用一个代理类调用原有的方法，且对产生的结果进行控制。这种方法就是代理模式。 使用代理模式，可以将功能划分的更加清晰，有助于后期维护！ 9.外观模式（Facade）外观模式是为了解决类与类之家的依赖关系的，像spring一样，可以将类和类之间的关系配置到配置文件中，而外观模式就是将他们的关系放在一个Facade类中，降低了类类之间的耦合度，该模式中没有涉及到接口.我们以一个计算机的启动过程为例，示例代码： 12345678910public class CPU &#123; public void startup()&#123; System.out.println("cpu startup!"); &#125; public void shutdown()&#123; System.out.println("cpu shutdown!"); &#125; &#125; 12345678910public class Memory &#123; public void startup()&#123; System.out.println("memory startup!"); &#125; public void shutdown()&#123; System.out.println("memory shutdown!"); &#125; &#125; 12345678910public class Disk &#123; public void startup()&#123; System.out.println("disk startup!"); &#125; public void shutdown()&#123; System.out.println("disk shutdown!"); &#125; &#125; 123456789101112131415161718192021222324252627public class Computer &#123; private CPU cpu; private Memory memory; private Disk disk; public Computer()&#123; cpu = new CPU(); memory = new Memory(); disk = new Disk(); &#125; public void startup()&#123; System.out.println("start the computer!"); cpu.startup(); memory.startup(); disk.startup(); System.out.println("start computer finished!"); &#125; public void shutdown()&#123; System.out.println("begin to close the computer!"); cpu.shutdown(); memory.shutdown(); disk.shutdown(); System.out.println("computer closed!"); &#125; &#125; User类实现如下： 12345678public class User &#123; public static void main(String[] args) &#123; Computer computer = new Computer(); computer.startup(); computer.shutdown(); &#125; &#125; 输出： 12345678910start the computer!cpu startup!memory startup!disk startup!start computer finished!begin to close the computer!cpu shutdown!memory shutdown!disk shutdown!computer closed! 如果我们没有Computer类，那么，CPU、Memory、Disk他们之间将会相互持有实例，产生关系，这样会造成严重的依赖，修改一个类，可能会带来其他类的修改，这不是我们想要看到的，有了Computer类，他们之间的关系被放在了Computer类里，这样就起到了解耦的作用，这，就是外观模式！ 10.桥接模式（Bridge）桥接模式就是把事物和其具体实现分开，使他们可以各自独立的变化。桥接的用意是：将抽象化与实现化解耦，使得二者可以独立变化，像我们常用的JDBC桥DriverManager一样，JDBC进行连接数据库的时候，在各个数据库之间进行切换，基本不需要动太多的代码，甚至丝毫不用动，原因就是JDBC提供统一接口，每个数据库提供各自的实现，用一个叫做数据库驱动的程序来桥接就行了。示例代码： 先定义接口： 123public interface Sourceable &#123; public void method(); &#125; 分别定义两个实现类： 1234567public class SourceSub1 implements Sourceable &#123; @Override public void method() &#123; System.out.println("this is the first sub!"); &#125; &#125; 1234567public class SourceSub2 implements Sourceable &#123; @Override public void method() &#123; System.out.println("this is the second sub!"); &#125; &#125; 定义一个桥，持有Sourceable的一个实例： 123456789101112131415public abstract class Bridge &#123; private Sourceable source; public void method()&#123; source.method(); &#125; public Sourceable getSource() &#123; return source; &#125; public void setSource(Sourceable source) &#123; this.source = source; &#125; &#125; 12345public class MyBridge extends Bridge &#123; public void method()&#123; getSource().method(); &#125; &#125; 测试类： 1234567891011121314151617public class BridgeTest &#123; public static void main(String[] args) &#123; Bridge bridge = new MyBridge(); /*调用第一个对象*/ Sourceable source1 = new SourceSub1(); bridge.setSource(source1); bridge.method(); /*调用第二个对象*/ Sourceable source2 = new SourceSub2(); bridge.setSource(source2); bridge.method(); &#125; &#125; 输出： 12this is the first sub!this is the second sub! 这样，就通过对Bridge类的调用，实现了对接口Sourceable的实现类SourceSub1和SourceSub2的调用。类似于我们JDBC连接的原理，有数据库学习基础的，一结合就都懂了。 11.组合模式（Composite）组合模式有时又叫部分-整体模式在处理类似树形结构的问题时比较方便。示例代码： 1234567891011121314151617181920212223242526272829303132333435363738394041public class TreeNode &#123; private String name; private TreeNode parent; private Vector&lt;TreeNode&gt; children = new Vector&lt;TreeNode&gt;(); public TreeNode(String name)&#123; this.name = name; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public TreeNode getParent() &#123; return parent; &#125; public void setParent(TreeNode parent) &#123; this.parent = parent; &#125; //添加孩子节点 public void add(TreeNode node)&#123; children.add(node); &#125; //删除孩子节点 public void remove(TreeNode node)&#123; children.remove(node); &#125; //取得孩子节点 public Enumeration&lt;TreeNode&gt; getChildren()&#123; return children.elements(); &#125; &#125; 123456789101112131415161718public class Tree &#123; TreeNode root = null; public Tree(String name) &#123; root = new TreeNode(name); &#125; public static void main(String[] args) &#123; Tree tree = new Tree("A"); TreeNode nodeB = new TreeNode("B"); TreeNode nodeC = new TreeNode("C"); nodeB.add(nodeC); tree.root.add(nodeB); System.out.println("build the tree finished!"); &#125; &#125; 使用场景：将多个对象组合在一起进行操作，常用于表示树形结构中，例如二叉树，数等。 12.享元模式（Flyweight）享元模式的主要目的是实现对象的共享，即共享池，当系统中对象多的时候可以减少内存的开销，通常与工厂模式一起使用。 当一个客户端请求时，工厂需要检查当前对象池中是否有符合条件的对象，如果有，就返回已经存在的对象，如果没有，则创建一个新对象，FlyWeight是超类。一提到共享池，我们很容易联想到Java里面的JDBC连接池，想想每个连接的特点，我们不难总结出：适用于作共享的一些个对象，他们有一些共有的属性，就拿数据库连接池来说，url、driverClassName、username、password及dbname，这些属性对于每个连接来说都是一样的，所以就适合用享元模式来处理，建一个工厂类，将上述类似属性作为内部数据，其它的作为外部数据，在方法调用时，当做参数传进来，这样就节省了空间，减少了实例的数量。 示例代码为数据库连接池： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647public class ConnectionPool &#123; private Vector&lt;Connection&gt; pool; /*公有属性*/ private String url = "jdbc:mysql://localhost:3306/test"; private String username = "root"; private String password = "root"; private String driverClassName = "com.mysql.jdbc.Driver"; private int poolSize = 100; private static ConnectionPool instance = null; Connection conn = null; /*构造方法，做一些初始化工作*/ private ConnectionPool() &#123; pool = new Vector&lt;Connection&gt;(poolSize); for (int i = 0; i &lt; poolSize; i++) &#123; try &#123; Class.forName(driverClassName); conn = DriverManager.getConnection(url, username, password); pool.add(conn); &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; &#125; /* 返回连接到连接池 */ public synchronized void release() &#123; pool.add(conn); &#125; /* 返回连接池中的一个数据库连接 */ public synchronized Connection getConnection() &#123; if (pool.size() &gt; 0) &#123; Connection conn = pool.get(0); pool.remove(conn); return conn; &#125; else &#123; return null; &#125; &#125; &#125; 通过连接池的管理，实现了数据库连接的共享，不需要每一次都重新创建连接，节省了数据库重新创建的开销，提升了系统的性能！ 关系型模式—11种第一类：通过父类与子类的关系进行实现。 第二类：两个类之间。 第三类：类的状态。 第四类：通过中间类 父类与子类关系13.策略模式（strategy）策略模式定义了一系列算法，并将每个算法封装起来，使他们可以相互替换，且算法的变化不会影响到使用算法的客户。需要设计一个接口，为一系列实现类提供统一的方法，多个实现类实现该接口，设计一个抽象类（可有可无，属于辅助类），提供辅助函数.示例代码：首先统一接口： 123public interface ICalculator &#123; public int calculate(String exp); &#125; 辅助类: 12345678910public abstract class AbstractCalculator &#123; public int[] split(String exp,String opt)&#123; String array[] = exp.split(opt); int arrayInt[] = new int[2]; arrayInt[0] = Integer.parseInt(array[0]); arrayInt[1] = Integer.parseInt(array[1]); return arrayInt; &#125; &#125; 三个实现类： 12345678public class Plus extends AbstractCalculator implements ICalculator &#123; @Override public int calculate(String exp) &#123; int arrayInt[] = split(exp,"\\+"); return arrayInt[0]+arrayInt[1]; &#125; &#125; 123456789public class Minus extends AbstractCalculator implements ICalculator &#123; @Override public int calculate(String exp) &#123; int arrayInt[] = split(exp,"-"); return arrayInt[0]-arrayInt[1]; &#125; &#125; 12345678public class Multiply extends AbstractCalculator implements ICalculator &#123; @Override public int calculate(String exp) &#123; int arrayInt[] = split(exp,"\\*"); return arrayInt[0]*arrayInt[1]; &#125; &#125; 简单的测试类： 123456789public class StrategyTest &#123; public static void main(String[] args) &#123; String exp = "2+8"; ICalculator cal = new Plus(); int result = cal.calculate(exp); System.out.println(result); &#125; &#125; 输出： 110 策略模式的决定权在用户，系统本身提供不同算法的实现，新增或者删除算法，对各种算法做封装。因此，策略模式多用在算法决策系统中，外部用户只需要决定用哪个算法即可。 14.模板方法模式（Template Method）解释一下模板方法模式，就是指：一个抽象类中，有一个主方法，再定义1…n个方法，可以是抽象的，也可以是实际的方法，定义一个类，继承该抽象类，重写抽象方法，通过调用抽象类，实现对子类的调用. 就是在AbstractCalculator类中定义一个主方法calculate，calculate()调用spilt()等，Plus和Minus分别继承AbstractCalculator类，通过对AbstractCalculator的调用实现对子类的调用，看下面的例子： 12345678910111213141516171819public abstract class AbstractCalculator &#123; /*主方法，实现对本类其它方法的调用*/ public final int calculate(String exp,String opt)&#123; int array[] = split(exp,opt); return calculate(array[0],array[1]); &#125; /*被子类重写的方法*/ abstract public int calculate(int num1,int num2); public int[] split(String exp,String opt)&#123; String array[] = exp.split(opt); int arrayInt[] = new int[2]; arrayInt[0] = Integer.parseInt(array[0]); arrayInt[1] = Integer.parseInt(array[1]); return arrayInt; &#125; &#125; 1234567public class Plus extends AbstractCalculator &#123; @Override public int calculate(int num1,int num2) &#123; return num1 + num2; &#125; &#125; 测试类： 123456789public class StrategyTest &#123; public static void main(String[] args) &#123; String exp = "8+8"; AbstractCalculator cal = new Plus(); int result = cal.calculate(exp, "\\+"); System.out.println(result); &#125; &#125; 我跟踪下这个小程序的执行过程：首先将exp和”\+”做参数，调用AbstractCalculator类里的calculate(String,String)方法，在calculate(String,String)里调用同类的split()，之后再调用calculate(int ,int)方法，从这个方法进入到子类中，执行完return num1 + num2后，将值返回到AbstractCalculator类，赋给result，打印出来。正好验证了我们开头的思路。 类之间的关系15.观察者模式（Observer）包括这个模式在内的接下来的四个模式，都是类和类之间的关系，不涉及到继承，学的时候应该 记得归纳，记得本文最开始的那个图。观察者模式很好理解，类似于邮件订阅和RSS订阅，当我们浏览一些博客或wiki时，经常会看到RSS图标，就这的意思是，当你订阅了该文章，如果后续有更新，会及时通知你。其实，简单来讲就一句话：当一个对象变化时，其它依赖该对象的对象都会收到通知，并且随着变化！对象之间是一种一对多的关系。 16.迭代子模式（Iterator）17.责任链模式（Chain of Responsibility）18.命令模式（Command）类的状态19.备忘录模式（Memento）20.状态模式（State）通过中间类21.访问者模式（Visitor）22.中介者模式（Mediator）23.解释器模式（Interpreter）]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java代码块]]></title>
    <url>%2F2018%2F05%2F17%2FJava%E4%BB%A3%E7%A0%81%E5%9D%97%2F</url>
    <content type="text"><![CDATA[定义在Java中使用｛｝括起来的代码被称为代码块 局部代码块局部位置，常用于限定变量的生命周期 构造代码块在类中的成员位置，用{}括起来的代码。每次调用构造方法执行前，都会先执行构造代码块。作用：可以把多个构造方法中的共同代码放到一起，对对象进行初始化。 静态代码块在类中的成员位置。用{}括起来的代码。只不过它用static关键字修饰。 执行顺序静态代码块－&gt;构造代码块－&gt;构造方法静态代码块：只执行一次构造代码块：每次调用构造方法的时候都执行 示例代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657class Code &#123; static &#123; int a = 1000; System.out.println(a); &#125; //构造代码块 &#123; int x = 100; System.out.println(x); &#125; //构造方法 public Code()&#123; System.out.println("code"); &#125; //构造方法 public Code(int a)&#123; System.out.println("code"); &#125; //构造代码块 &#123; int y = 200; System.out.println(y); &#125; //静态代码块 static &#123; int b = 2000; System.out.println(b); &#125;&#125;class CodeDemo &#123; public static void main(String[] args) &#123; //局部代码块 &#123; int x = 10; System.out.println(x); &#125; //找不到符号 //System.out.println(x); &#123; int y = 20; System.out.println(y); &#125; System.out.println("---------------"); Code c = new Code(); System.out.println("---------------"); Code c2 = new Code(); System.out.println("---------------"); Code c3 = new Code(1); &#125;&#125;]]></content>
      <categories>
        <category>Java笔记</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java中的构造方法]]></title>
    <url>%2F2018%2F05%2F17%2FJava%E4%B8%AD%E7%9A%84%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[构造方法作用用于对对象的属性进行初始化 构造方法格式 方法名必须与类名相同 没有返回值类型，void也没有 没有返回值 构造方法的注意事项 如果我们没写构造方法，系统会提供一个默认的无参构造方法 如果我们写了构造方法，系统将不再提供默认的构造方法，需要我们自己写出无参构造方法 案例1234567891011121314151617181920212223242526272829303132333435363738394041class Student &#123; private String name; private int age; public Student()&#123;&#125; public Student(String name,int age) &#123; this.name = name; this.age = age; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; &#125; class StudentDemo &#123; public static void main(String[] args) &#123; //方式1 Student s1 = new Student(); s1.setName("王五"); s1.setAge(27); System.out.println(s1.getName()+"---"+s1.getAge()); //方式2 Student s2 = new Student("赵六",30); System.out.println(s2.getName()+"---"+s2.getAge()); &#125; &#125; 代码执行过程 把Student.class文件加载到内存 在栈内存为s开辟空间 在堆内存为学生对象申请空间 给学生的成员变量进行默认初始化。null,0 给学生的成员变量进行显示初始化。王五,27 通过构造方法给成员变量进行初始化。赵六,30 对象构造完毕，把地址赋值给s变量]]></content>
      <categories>
        <category>Java笔记</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java笔记——static关键字]]></title>
    <url>%2F2018%2F05%2F17%2FJava%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E7%B1%BB%E4%B8%8E%E5%AF%B9%E8%B1%A1%E6%A6%82%E8%BF%B0%2F</url>
    <content type="text"><![CDATA[static特点 随着类的加载而加载 优先与对象存在 被类的所有对象共享 可以通过类名调用 静态变量与成员变量区别 所属不同 静态变量：属于类，类变量 成员变量：属于对象，对象变量 生命周期不同 静态变量：随着类的加载而加载，随着类的消失而消失 成员变量：随着对象的创建而存在，随着对象的消失而消失 调用不同 静态变量：可以通过对象名也可以通过类名调用 成员变量：只能通过对象名调用]]></content>
      <categories>
        <category>Java个人笔记</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL学习笔记.MySQL语法]]></title>
    <url>%2F2018%2F05%2F15%2FMySQL%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-MySQL%E8%AF%AD%E6%B3%95%2F</url>
    <content type="text"><![CDATA[SQL语句分类 DDL(Data Definition Language) 数据定义语言 功能：创建、删除、修改库和表结构 DML(Data Manipulation Language) 数据操作语言 功能：增、删、改表记录 DCL(Data Control Language) 数据库控制语言 功能：用来定义访问权限和安全级别 DQL(Data Query Language) 数据库查询语言 功能：用来查询纪录 DDL(数据定义语言)语法数据库相关操作查看所有数据库:SHOW DATABASES; 使用数据库：USE 数据库名; 创建数据库并指定编码：CREATE DATABASE [IF NOT EXISTS] 数据库名 [DEFAULT CHARACTER SET UTF8]; 删除数据库：DROP DATABASE 数据库名; 修改数据编码：ALTER DATABASE 数据库名 CHARACTER SET UTF-8; 数据表相关操作创建表：12345CREATE TABLE (IF NOT EXISTS) 表名(列名 列类型，...，列名 列类型)； 查看表结构：DESC 表名; 删除表：DROP 表名; 修改表：修改表有5个操作，前缀名都相同：ALTER TABLE 表名... 添加列：ALTER TABLE 表名 add (列名 列类型，...，列名 列类型); 修改列类型：ALTER TABLE 表名 MODIFY 列名 列的新类型; 列名称列类型一起修改：ALTER TABLE 表名 CHANGE 原列名 新列名 列名类型; 删除列：ALTER TABLE 表名 DROP 列名; 修改表名：ALTER TABLE 表名 RENAME TO 新表名 DML(数据操作语言)语法插入数据insert into 表名 (列名1，列名2，列名3) values (列值1，列值2，列值3) 修改数据修改某列的全部值：insert into 表名 (列名1，列名2，列名3) values (列值1，列值2，列值3) 修改某行或多行记录的列的指定值：update 表名 set 列名1=列值1 where 列名2=列值2 or 列名3=列值3; 删除数据delete from 表名 (where 条件);注意不加where条件时会删除表中的所有记录。 DCL(数据控制语言)语法用来定义用户访问权限。 创建用户用户只能在指定的IP地址上登录mysql:create user 用户名@IP地址 identified by ‘密码’； 用户可以在任意的IP地址上登录mysql：create user 用户名@‘％’ identified by ‘密码’； 给用户授权语法：grant 权限1，…，权限n on 数据库.* to 用户名@IP地址；其中权限1、2、n可以直接用all关键字代替。权限例如:create,alter,drop,insert,update,delete,select。 撤销授权语法:revoke 权限1，…，权限n on 数据库.* from 用户名@ ip地址；撤销指定用户在指定数据库上的指定权限。撤销例如:revoke create,delete on mydb1.* form user@localhost;表示的意思是撤消user用户在数据库mydb1伤的create、alter权限。 查看权限查看指定用户的权限:show grants for 用户名@ip地址； 删除用户drop user 用户名@ip地址； DQL(数据查询语言)语法用来查询记录，不会修改数据库和表结构。select 列名 from 表名 where 条件MySQL LIKE 子句 :SELECT * from runoob_tbl WHERE runoob_author LIKE &#39;%COM&#39; 基本查询列控制 查询所有列：select * from 表名;其中＊表示查询所有列，而不是所有行的意思。 查询指定列：select 列1，列2，列n from 表名； 完全重复的记录只显示一次:在查询的列之前添加distinct:select distinct $ from 表名；缺省值为all。 列运算 数量类型的列可以做加、减、乘、除:SELECT sal*5 from 表名；说明:1.遇到null加任何值都等于null的情况，需要用到ifnull()函数。2.将字符串做加减乘除运算，会把字符串当作0。 字符串累类型可以做连续运算(需要用到concat()函数):select concat(列名1，列名2) from 表名;其中列名的类型要为字符串。 给列名起别名:select 列名1 (as) 别名1,列名2 (as) 别名2 from 表名； 条件控制 条件查询(在后面添加where指定条件)select * from 表名 where 列名＝指定值; 模糊查询(当你想查询所有姓张的记录)select * from 表名 where 列名 like ‘张_’;(_代表匹配任意一个字符，％代表匹配0～n个任意字符)。 排序 升序:select * form 表名 order by 列名 (ASC ); ()里面的内容为缺省值； 降序:select * from 表名 order by 列名 DESC; 使用多列作为排序条件: 当第一列排序条件相同时，根据第二列排序条件排序(当第二列依旧相同时可视情况根据第三例条件排序)。select * from 表名 order by 列名1 ASC, 列名2 DESC;意思是当列名1的值相同时按照列名2的值降序排。 聚合函数 count:select count(列名) from 表名；,纪录有效行数。 max:select max(列名) from 表名；,列中最大值。 min:select min(列名) from 表名；,列中最小值。 sum:select sum(列名) from 表名；,求列的总值，null 和字符串默认为0。 avg:select avg(列名) from 表名;,一列的平均值。 分组查询LIMIT子句(mysql中独有的语法)LIMIT用来限定查询结果的起始行，以及总行数。例如：select * from 表名 limit 4，3；表示起始行为第5行，一共查询3行记录。]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>MySql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Windows下安装MySql]]></title>
    <url>%2F2018%2F05%2F14%2FWindows%E4%B8%8B%E5%AE%89%E8%A3%85MySql%2F</url>
    <content type="text"><![CDATA[下载MySql 下载地址：https://dev.mysql.com/downloads/mysql/ 下载zip包： 下载后解压：D:\软件安装包\mysql-5.7.20-winx64 环境变量配置 变量名：MYSQL_HOME 变量值：D:\软件安装包\mysql-5.7.20-winx64 path里添加：%MYSQL_HOME%\bin;生成data文件： 以管理员身份运行cmd,进入D:\软件安装包\mysql-5.7.20-winx64\bin下，执行命令：mysqld --initialize-insecure --user=mysql 启动服务执行命令：net start mysql启动mysql服务，若提示：服务名无效等问题详见问题解决，若成功启动服务则安装成功。 问题解决提示：服务名无效解决方法：执行命令：mysqld -install即可若提示服务正在启动或停止中，请稍候片刻再试一次。则需要先去资源管理器中把mysql进程结束，重新启动即可。 登录mysql以管理员身份运行cmd,进入D:\软件安装包\mysql-5.7.20-winx64\bin下，执行命令：mysql -u root -p因为之前没设置密码，所以密码为空，不用输入密码，直接回车即可。 设置或修改密码 修改 update mysql.user set authentication_string=password(&quot;123456&quot;) where user =&quot;root&quot; 注意password(“123456”),此处引号中的内容是密码，自己可以随便设置 保存 flush privileges作用：相当于保存，执行此命令后，设置才生效，若不执行，还是之前的密码不变]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>MySql</tag>
        <tag>Windows</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java中String、StringBuilder和StringBuffer的区别]]></title>
    <url>%2F2018%2F05%2F14%2FJava%E4%B8%ADString%E3%80%81StringBuilder%E5%92%8CStringBuffer%E7%9A%84%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[整理下Java中String，StringBuilder和StringBuffer知识点的理解。 String字符串常量 StringBuffer字符串变量（线程安全） StringBuilder字符串变量（非线程安全） String所谓常量，即该对象的值已经被赋予了，不能再更改了，若非要更改，则只能再重新创建另一个对象，在这个新创建的对象上再进行赋值。因此，每次在对String类型的对象进行改变的时候其实都等同于生成了一个新的String对象，然后指针指向新的String对象，所以经常改变内容的字符串最好不要用String。 StringBuffer所谓变量，即是可以随时变化的量。如果对StringBuffer对象进行改变，每次结果都会对StringBuffer对象进行操作，而不是生成新的对象。所以一般字符串要经常变化的话我推荐使用StringBuffer。 StringBuilderStringBuilder和StringBuffer类功能基本相似，方法也差不多，主要区别在于StringBuffer类的方法是多线程安全的，而StringBuilder不是线程安全的，相比而言StringBuilder类会略微快一点。]]></content>
      <categories>
        <category>Java笔记</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mac用户如何将自己的代码上传至Git]]></title>
    <url>%2F2018%2F05%2F14%2FMac%E7%94%A8%E6%88%B7%E5%A6%82%E4%BD%95%E5%B0%86%E8%87%AA%E5%B7%B1%E7%9A%84%E4%BB%A3%E7%A0%81%E4%B8%8A%E4%BC%A0%E8%87%B3Git%2F</url>
    <content type="text"><![CDATA[写在前面在尝试将自己的代码上传至Github上时走了不少弯路，后来偶然成功后，写下此教程，下面介绍通过git命令行来上传自己的代码。 通过git命令行git命令虽然很多，不过会基本的常用的命令，就还可以。 git init(作用：初始化你的文件夹） git add（作用：将你的仓库添加至远程） git commit -m&quot;你想输入的信息“(作用：将你的仓库提交至远程） git push origin master(作用：将你的仓库上传至远程）完成这四个步骤，就可以把代码上传到github上了。 详细步骤 下载git 12ruby -e “$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)”brew install git 查看是否安装好git，打开终端输入git -version 若显示版本号即安装成功 克隆你github上面的项目到本地仓库，在命令行输入以下代码：git clone url然后回车。 这时你就可以看到你的电脑上多了一个以你仓库命名的文件夹啦。（其中url指你github上面仓库的地址，点开你的仓库就可以看到你仓库的地址啦。） 首先将你想上传的代码文件夹拖至这个新出现的仓库文件夹，然后命令行输入：cd 你的仓库文件夹名称接下来输入：git add 你想上传的代码文件夹名称或者是输入：git add.(add后面的.表示上传仓库中的所有内容）然后输入：git commit -m &quot;你想交代的内容&quot;最后输入：git push origin master过一小会就能在github的仓库中看到你上传的代码文件夹了。]]></content>
      <categories>
        <category>Github</category>
      </categories>
      <tags>
        <tag>Github</tag>
        <tag>Mac</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo+GitHub博客搭建实战]]></title>
    <url>%2F2018%2F05%2F13%2FHexo-GitHub%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E5%AE%9E%E6%88%98%2F</url>
    <content type="text"><![CDATA[Github的注册大家点击https://github.com/按要求注册即可。 username一定要起一个好听的名字，这在创建博客域名的时候会用到 搭建环境 安装Node.js:https://nodejs.org/en/windows下点击链接，下载安装（下一步下一步下一步…) 安装Git:https://github.com/waylau/git-for-win同上windows下点击上述链接安装即可，不知道Git和Node.js的小伙伴也不要紧，就先知道是必须要有的环境就好。 安装完成后，在开始菜单里找到“Git“-&gt;”Git Bash“,按下图设置，名字和邮箱是Github上的。 安装hexonpm install -g hexo-cli至此本地环境已经搭建完成，下一步开始配置Github 配置Github 登录你刚才注册的Github帐号 点击Create a new repository如下图所示：其中仓库名称Respository name只能填写为，注意！！！是只能填写为你注册的用户名.github.io其他的一概不行！！！仓库创建完成后，开始生成添加秘钥。在终端下输入ssh-keygen -t rsa -C &quot;Github的注册邮箱地址&quot;一路一直按Enter过来就行，待秘钥生成完毕后会得到两个文件id_rsa和id_rsa.pub，用任意文本编辑器打开id_rsa.pub，全选里面的内容复制，然后进入https://github.com/settings/ssh将复制的内容粘贴到Key的输入框，Title里的内容可以随意填写，点击Add SSH key按钮即可。 初始化博客 在电脑里随便一个盘内，新建文件夹test,进入test,按住Shift键点击鼠标右键，点击此处打开命令窗口:输入：hexo init blog稍等片刻，待最后出现成功提示： INFO Start blogging with Hexo! 由于初始化hexo后source目录下自带一篇hello world文章，所以直接输入下面的命令 hexo generate hexo server 在浏览器输入 http://localhost:4000/就可以看见你的博客了 别激动这只是把网站部署到本地，别人看不见，下面我们把网站部署到Github上。 配置博客在blog目录下，用文本编辑器打开_config.yml文件，下面我们来修改参数信息 提示，修改的时候在每个参数的:后面都需要有一个空格,这里没写的先不要修改。 修改网站相关信息123456title: xxx的博客subtitle: 个性签名description: 网页描述author：作者language: zh-CNtimezone: Asia/Shanghai 配置部署1234deploy: type: git repo: https://github.com/你的用户名/你的用户名.github.io branch: master 配置统一资源定位url: https://你的用户名.github.io 发表文章 在命令行中输入hexo new &quot;我的测试文章&quot; 按提示路径找到该文章，打开后可使用Markdown语法编辑文章 接着在blog目录下，输入如下三个命令 hexo clean hexo generate hexo server(此时已经可以在本地浏览了，第4步可发送到远程） hexo deploy正常情况下会跳出Github登录，直接登录即可 若无错误，在浏览器输入博客地址：你的用户名.github.io，就可以看到内容了。]]></content>
      <categories>
        <category>个人博客搭建</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>Github</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySelf]]></title>
    <url>%2F2018%2F05%2F13%2FMySelf%2F</url>
    <content type="text"><![CDATA[联系方式 微信号：pyy19980724 邮箱：849200701@qq.com 手机号：无 个人信息 本科／大连大学计算机系软件工程专业 现阶段学历：本科大二在读 技术博客：https://atooms.github.io Github：https://github.com/ATOOMs 期望职位：Java开发工程师 期望城市：大连，沈阳 工作经历 待更新 开源项目和作品 待更新 技术文章 待更新 技能清单 待更新 致谢感谢您花时间阅读我的简历，期待能有机会和您共事。]]></content>
      <tags>
        <tag>个人简历</tag>
      </tags>
  </entry>
</search>
