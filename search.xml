<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[23种设计模式（Java版）]]></title>
    <url>%2F2018%2F09%2F09%2F23%E7%A7%8D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%88Java%E7%89%88%EF%BC%89%2F</url>
    <content type="text"><![CDATA[设计模式的分类主要分为三大类：创建型模式，共五种：工厂方法模式，抽象工厂模式，单例模式，建造者模式，原型模式。结构型模式，共七种：适配器模式，装饰器模式，代理模式，外观模式，桥接模式，组合模式，享元模式。行为型模式，共十一种：策略模式，模板方法模式，观察者模式，迭代子模式，责任链模式，命令模式，备忘录模式，状态模式，访问者模式，中介者模式，解释器模式。还有两小类：并发行模式和线程池模式。 设计模式的六大原则总原则：开闭原则（Open CLose Principle)开闭原则就是说对扩展开放，对修改关闭。在程序需要进行拓展的时候，不能去修改原有的代码，而是要扩展原有代码，实现一个热插拔的效果。所以一句话概括就是：为了使程序的扩展性好，易于维护和升级。想要达到这样的效果，需要使用接口和抽象类等。 单一职责原则不要存在多于一个导致类变更的原因，也就是说每个类应该实现单一的职责，如若不然，就应该把类拆分。 里氏替换原则（Liskov Substitution Principle）里氏代换原则中说，任何基类可以出现的地方，子类一定可以出现。 LSP是继承复用的基石，只有当衍生类可以替换掉基类，软件单位的功能不受到影响时，基类才能真正被复用，而衍生类也能够在基类的基础上增加新的行为。里氏代换原则是对“开-闭”原则的补充。实现“开-闭”原则的关键步骤就是抽象化。而基类与子类的继承关系就是抽象化的具体实现，所以里氏代换原则是对实现抽象化的具体步骤的规范。里氏替换原则中，子类对父类的方法尽量不要重写和重载。因为父类代表了定义好的结构，通过这个规范的接口与外界交互，子类不应该随便破坏它。 依赖倒转原则（Dependence Inversion Principle）这个是开闭原则的基础，具体内容：面向接口编程，依赖于抽象而不依赖于具体。写代码时用到具体类时，不与具体类交互，而与具体类的上层接口交互。 接口隔离原则（Interface Segregation Principle）这个原则的意思是：每个接口中不存在子类用不到却必须实现的方法，如果不然，就要将接口拆分。使用多个隔离的接口，比使用单个接口（多个接口方法集合到一个的接口）要好。 迪米特法则（最少知道原则）（Demeter Principle）就是说：一个类对自己依赖的类知道的越少越好。也就是说无论被依赖的类多么复杂，都应该将逻辑封装在方法的内部，通过public方法提供给外部。这样当被依赖的类变化时，才能最小的影响该类。最少知道原则的另一个表达方式是：只与直接的朋友通信。类之间只要有耦合关系，就叫朋友关系。耦合分为依赖、关联、聚合、组合等。我们称出现为成员变量、方法参数、方法返回值中的类为直接朋友。局部变量、临时变量则不是直接的朋友。我们要求陌生的类不要作为局部变量出现在类中。 合成复用原则（Composite Reuse Principle）原则是尽量首先使用合成/聚合的方式，而不是使用继承。 Java的23种设计模式创建型模式—5种首先，简单工厂模式不属于23种设计模式，简单工厂一般分为：普通简单工厂、多方法简单工厂、静态方法简单工厂。 简单工厂模式(不属于23种设计模式，作为引入放在前面的位置)1.普通简单工厂模式就是建立一个工厂类，对实现了同一接口的一些类进行实例的创建。 工厂生产手机（实例） 先定义手机接口Mobile 123public interface Mobile &#123; public void call();&#125; 再定义具体产品–小米和魅族手机，它们都带有Mobile接口 123456public class MeiZu implements Mobile&#123; public void call() &#123; System.out.println("MeiZu手机"); &#125;&#125; 123456public class XiaoMi implements Mobile&#123; public void call() &#123; System.out.println("XiaoMi手机"); &#125;&#125; 再定义简单工厂类MobileFactory通过传入的参数来确定返回哪种手机的相关信息 1234567891011121314151617public class MobileFactory &#123; public Mobile getMobile (String title) throws Exception &#123; if(title.equalsIgnoreCase("xiaomi")) &#123; return new XiaoMi(); &#125; else if(title.equalsIgnoreCase("meizu")) &#123; return new MeiZu(); &#125; else &#123; throw new Exception("no such "+title+"mobile found"); &#125; &#125;&#125; 创建测试类test测试 12345678910111213141516171819202122232425262728293031323334353637public class test &#123; public static void main(String[] args) &#123; // TODO Auto-generated method stub try &#123; MobileFactory mf = new MobileFactory(); Mobile m; m=mf.getMobile("xiaomi"); m.call(); m=mf.getMobile("meizu"); m.call(); &#125; catch(Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125;#### 2.多方法简单工厂模式是对普通工厂方法模式的改进，在普通工厂方法模式中，如果传递的字符串出错，则不能正确创建对象，而多个工厂方法模式是提供多个工厂方法，分别创建对象。&lt;br/&gt;只需要修改MobileFactory类就可以，如下：```javapublic class MobileFactory&#123; public Mobile produceXiaoMi() &#123; return new XiaoMi(); &#125; pubilc Mobile produceMeiZu() &#123; return new MeiZu(); &#125;&#125; 测试类修改如下： 12345678910111213141516171819public class test &#123; public static void main(String[] args) &#123; // TODO Auto-generated method stub try &#123; MobileFactory mf = new MobileFactory(); Mobile m; m=mf.produceXiaoMi(); m.call(); m=mf.produceMeiZu(); m.call(); &#125; catch(Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125; 3.静态工厂方法模式将上面的多方法模式里的方法置为静态的，不需要创建实例，直接调用即可。总体来说，工厂模式适合：凡是出现了大量的产品需要创建，并且具有共同的接口时，可以通过工厂方法模式进行创建。在以上的三种模式中，第一种如果传入的字符串有误，不能正确创建对象，第三种相对于第二种，不需要实例化工厂类，所以，大多数情况下，我们会选用第三种——静态工厂方法模式。 1.工厂方法模式（Factory Method）2.抽象工厂模式3.单例模式（Singleton）4.建造者模式（Builder）5.原型模式（Prototype）结构型模式—7种6.适配器模式类的适配器模式对象的适配器模式接口的适配器模式7.装饰模式（Decorator）8.代理模式（Proxy）9.外观模式（Facade）10.桥接模式（Bridge）11.组合模式（Composite）12.享元模式（Flyweight）关系型模式—11种父类与子类关系13.策略模式（strategy）14.模板方法模式（Template Method）类之间的关系15.观察者模式（Observer）16.迭代子模式（Iterator）17.责任链模式（Chain of Responsibility）18.命令模式（Command）类的状态19.备忘录模式（Memento）20.状态模式（State）通过中间类21.访问者模式（Visitor）22.中介者模式（Mediator）23.解释器模式（Interpreter）]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java代码块]]></title>
    <url>%2F2018%2F05%2F17%2FJava%E4%BB%A3%E7%A0%81%E5%9D%97%2F</url>
    <content type="text"><![CDATA[定义在Java中使用｛｝括起来的代码被称为代码块 局部代码块局部位置，常用于限定变量的生命周期 构造代码块在类中的成员位置，用{}括起来的代码。每次调用构造方法执行前，都会先执行构造代码块。作用：可以把多个构造方法中的共同代码放到一起，对对象进行初始化。 静态代码块在类中的成员位置。用{}括起来的代码。只不过它用static关键字修饰。 执行顺序静态代码块－&gt;构造代码块－&gt;构造方法静态代码块：只执行一次构造代码块：每次调用构造方法的时候都执行 示例代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657class Code &#123; static &#123; int a = 1000; System.out.println(a); &#125; //构造代码块 &#123; int x = 100; System.out.println(x); &#125; //构造方法 public Code()&#123; System.out.println("code"); &#125; //构造方法 public Code(int a)&#123; System.out.println("code"); &#125; //构造代码块 &#123; int y = 200; System.out.println(y); &#125; //静态代码块 static &#123; int b = 2000; System.out.println(b); &#125;&#125;class CodeDemo &#123; public static void main(String[] args) &#123; //局部代码块 &#123; int x = 10; System.out.println(x); &#125; //找不到符号 //System.out.println(x); &#123; int y = 20; System.out.println(y); &#125; System.out.println("---------------"); Code c = new Code(); System.out.println("---------------"); Code c2 = new Code(); System.out.println("---------------"); Code c3 = new Code(1); &#125;&#125;]]></content>
      <categories>
        <category>Java个人笔记</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java中的构造方法]]></title>
    <url>%2F2018%2F05%2F17%2FJava%E4%B8%AD%E7%9A%84%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[构造方法作用用于对对象的属性进行初始化 构造方法格式 方法名必须与类名相同 没有返回值类型，void也没有 没有返回值 构造方法的注意事项 如果我们没写构造方法，系统会提供一个默认的无参构造方法 如果我们写了构造方法，系统将不再提供默认的构造方法，需要我们自己写出无参构造方法 案例1234567891011121314151617181920212223242526272829303132333435363738394041class Student &#123; private String name; private int age; public Student()&#123;&#125; public Student(String name,int age) &#123; this.name = name; this.age = age; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; &#125; class StudentDemo &#123; public static void main(String[] args) &#123; //方式1 Student s1 = new Student(); s1.setName("王五"); s1.setAge(27); System.out.println(s1.getName()+"---"+s1.getAge()); //方式2 Student s2 = new Student("赵六",30); System.out.println(s2.getName()+"---"+s2.getAge()); &#125; &#125; 代码执行过程 把Student.class文件加载到内存 在栈内存为s开辟空间 在堆内存为学生对象申请空间 给学生的成员变量进行默认初始化。null,0 给学生的成员变量进行显示初始化。王五,27 通过构造方法给成员变量进行初始化。赵六,30 对象构造完毕，把地址赋值给s变量]]></content>
      <categories>
        <category>Java个人笔记</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java笔记——static关键字]]></title>
    <url>%2F2018%2F05%2F17%2FJava%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E7%B1%BB%E4%B8%8E%E5%AF%B9%E8%B1%A1%E6%A6%82%E8%BF%B0%2F</url>
    <content type="text"><![CDATA[static特点 随着类的加载而加载 优先与对象存在 被类的所有对象共享 可以通过类名调用 静态变量与成员变量区别 所属不同 静态变量：属于类，类变量 成员变量：属于对象，对象变量 生命周期不同 静态变量：随着类的加载而加载，随着类的消失而消失 成员变量：随着对象的创建而存在，随着对象的消失而消失 调用不同 静态变量：可以通过对象名也可以通过类名调用 成员变量：只能通过对象名调用]]></content>
      <categories>
        <category>Java个人笔记</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL学习笔记.MySQL语法]]></title>
    <url>%2F2018%2F05%2F15%2FMySQL%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-MySQL%E8%AF%AD%E6%B3%95%2F</url>
    <content type="text"><![CDATA[SQL语句分类 DDL(Data Definition Language) 数据定义语言 功能：创建、删除、修改库和表结构 DML(Data Manipulation Language) 数据操作语言 功能：增、删、改表记录 DCL(Data Control Language) 数据库控制语言 功能：用来定义访问权限和安全级别 DQL(Data Query Language) 数据库查询语言 功能：用来查询纪录 DDL(数据定义语言)语法数据库相关操作查看所有数据库:SHOW DATABASES; 使用数据库：USE 数据库名; 创建数据库并指定编码：CREATE DATABASE [IF NOT EXISTS] 数据库名 [DEFAULT CHARACTER SET UTF8]; 删除数据库：DROP DATABASE 数据库名; 修改数据编码：ALTER DATABASE 数据库名 CHARACTER SET UTF-8; 数据表相关操作创建表：12345CREATE TABLE (IF NOT EXISTS) 表名(列名 列类型，...，列名 列类型)； 查看表结构：DESC 表名; 删除表：DROP 表名; 修改表：修改表有5个操作，前缀名都相同：ALTER TABLE 表名... 添加列：ALTER TABLE 表名 add (列名 列类型，...，列名 列类型); 修改列类型：ALTER TABLE 表名 MODIFY 列名 列的新类型; 列名称列类型一起修改：ALTER TABLE 表名 CHANGE 原列名 新列名 列名类型; 删除列：ALTER TABLE 表名 DROP 列名; 修改表名：ALTER TABLE 表名 RENAME TO 新表名 DML(数据操作语言)语法插入数据insert into 表名 (列名1，列名2，列名3) values (列值1，列值2，列值3) 修改数据修改某列的全部值：insert into 表名 (列名1，列名2，列名3) values (列值1，列值2，列值3) 修改某行或多行记录的列的指定值：update 表名 set 列名1=列值1 where 列名2=列值2 or 列名3=列值3; 删除数据delete from 表名 (where 条件);注意不加where条件时会删除表中的所有记录。 DCL(数据控制语言)语法用来定义用户访问权限。 创建用户用户只能在指定的IP地址上登录mysql:create user 用户名@IP地址 identified by ‘密码’； 用户可以在任意的IP地址上登录mysql：create user 用户名@‘％’ identified by ‘密码’； 给用户授权语法：grant 权限1，…，权限n on 数据库.* to 用户名@IP地址；其中权限1、2、n可以直接用all关键字代替。权限例如:create,alter,drop,insert,update,delete,select。 撤销授权语法:revoke 权限1，…，权限n on 数据库.* from 用户名@ ip地址；撤销指定用户在指定数据库上的指定权限。撤销例如:revoke create,delete on mydb1.* form user@localhost;表示的意思是撤消user用户在数据库mydb1伤的create、alter权限。 查看权限查看指定用户的权限:show grants for 用户名@ip地址； 删除用户drop user 用户名@ip地址； DQL(数据查询语言)语法用来查询记录，不会修改数据库和表结构。select 列名 from 表名 where 条件MySQL LIKE 子句 :SELECT * from runoob_tbl WHERE runoob_author LIKE &#39;%COM&#39; 基本查询列控制 查询所有列：select * from 表名;其中＊表示查询所有列，而不是所有行的意思。 查询指定列：select 列1，列2，列n from 表名； 完全重复的记录只显示一次:在查询的列之前添加distinct:select distinct $ from 表名；缺省值为all。 列运算 数量类型的列可以做加、减、乘、除:SELECT sal*5 from 表名；说明:1.遇到null加任何值都等于null的情况，需要用到ifnull()函数。2.将字符串做加减乘除运算，会把字符串当作0。 字符串累类型可以做连续运算(需要用到concat()函数):select concat(列名1，列名2) from 表名;其中列名的类型要为字符串。 给列名起别名:select 列名1 (as) 别名1,列名2 (as) 别名2 from 表名； 条件控制 条件查询(在后面添加where指定条件)select * from 表名 where 列名＝指定值; 模糊查询(当你想查询所有姓张的记录)select * from 表名 where 列名 like ‘张_’;(_代表匹配任意一个字符，％代表匹配0～n个任意字符)。 排序 升序:select * form 表名 order by 列名 (ASC ); ()里面的内容为缺省值； 降序:select * from 表名 order by 列名 DESC; 使用多列作为排序条件: 当第一列排序条件相同时，根据第二列排序条件排序(当第二列依旧相同时可视情况根据第三例条件排序)。select * from 表名 order by 列名1 ASC, 列名2 DESC;意思是当列名1的值相同时按照列名2的值降序排。 聚合函数 count:select count(列名) from 表名；,纪录有效行数。 max:select max(列名) from 表名；,列中最大值。 min:select min(列名) from 表名；,列中最小值。 sum:select sum(列名) from 表名；,求列的总值，null 和字符串默认为0。 avg:select avg(列名) from 表名;,一列的平均值。 分组查询LIMIT子句(mysql中独有的语法)LIMIT用来限定查询结果的起始行，以及总行数。例如：select * from 表名 limit 4，3；表示起始行为第5行，一共查询3行记录。]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>MySql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Windows下安装MySql]]></title>
    <url>%2F2018%2F05%2F14%2FWindows%E4%B8%8B%E5%AE%89%E8%A3%85MySql%2F</url>
    <content type="text"><![CDATA[下载MySql 下载地址：https://dev.mysql.com/downloads/mysql/ 下载zip包： 下载后解压：D:\软件安装包\mysql-5.7.20-winx64 环境变量配置 变量名：MYSQL_HOME 变量值：D:\软件安装包\mysql-5.7.20-winx64 path里添加：%MYSQL_HOME%\bin;生成data文件： 以管理员身份运行cmd,进入D:\软件安装包\mysql-5.7.20-winx64\bin下，执行命令：mysqld --initialize-insecure --user=mysql 启动服务执行命令：net start mysql启动mysql服务，若提示：服务名无效等问题详见问题解决，若成功启动服务则安装成功。 问题解决提示：服务名无效解决方法：执行命令：mysqld -install即可若提示服务正在启动或停止中，请稍候片刻再试一次。则需要先去资源管理器中把mysql进程结束，重新启动即可。 登录mysql以管理员身份运行cmd,进入D:\软件安装包\mysql-5.7.20-winx64\bin下，执行命令：mysql -u root -p因为之前没设置密码，所以密码为空，不用输入密码，直接回车即可。 设置或修改密码 修改 update mysql.user set authentication_string=password(&quot;123456&quot;) where user =&quot;root&quot; 注意password(“123456”),此处引号中的内容是密码，自己可以随便设置 保存 flush privileges作用：相当于保存，执行此命令后，设置才生效，若不执行，还是之前的密码不变]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>MySql</tag>
        <tag>Windows</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java中String、StringBuilder和StringBuffer的区别]]></title>
    <url>%2F2018%2F05%2F14%2FJava%E4%B8%ADString%E3%80%81StringBuilder%E5%92%8CStringBuffer%E7%9A%84%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[整理下Java中String，StringBuilder和StringBuffer知识点的理解。 String字符串常量 StringBuffer字符串变量（线程安全） StringBuilder字符串变量（非线程安全） String所谓常量，即该对象的值已经被赋予了，不能再更改了，若非要更改，则只能再重新创建另一个对象，在这个新创建的对象上再进行赋值。因此，每次在对String类型的对象进行改变的时候其实都等同于生成了一个新的String对象，然后指针指向新的String对象，所以经常改变内容的字符串最好不要用String。 StringBuffer所谓变量，即是可以随时变化的量。如果对StringBuffer对象进行改变，每次结果都会对StringBuffer对象进行操作，而不是生成新的对象。所以一般字符串要经常变化的话我推荐使用StringBuffer。 StringBuilderStringBuilder和StringBuffer类功能基本相似，方法也差不多，主要区别在于StringBuffer类的方法是多线程安全的，而StringBuilder不是线程安全的，相比而言StringBuilder类会略微快一点。]]></content>
      <categories>
        <category>Java笔记</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mac用户如何将自己的代码上传至Git]]></title>
    <url>%2F2018%2F05%2F14%2FMac%E7%94%A8%E6%88%B7%E5%A6%82%E4%BD%95%E5%B0%86%E8%87%AA%E5%B7%B1%E7%9A%84%E4%BB%A3%E7%A0%81%E4%B8%8A%E4%BC%A0%E8%87%B3Git%2F</url>
    <content type="text"><![CDATA[写在前面在尝试将自己的代码上传至Github上时走了不少弯路，后来偶然成功后，写下此教程，下面介绍通过git命令行来上传自己的代码。 通过git命令行git命令虽然很多，不过会基本的常用的命令，就还可以。 git init(作用：初始化你的文件夹） git add（作用：将你的仓库添加至远程） git commit -m&quot;你想输入的信息“(作用：将你的仓库提交至远程） git push origin master(作用：将你的仓库上传至远程）完成这四个步骤，就可以把代码上传到github上了。 详细步骤 下载git 12ruby -e “$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)”brew install git 查看是否安装好git，打开终端输入git -version 若显示版本号即安装成功 克隆你github上面的项目到本地仓库，在命令行输入以下代码：git clone url然后回车。 这时你就可以看到你的电脑上多了一个以你仓库命名的文件夹啦。（其中url指你github上面仓库的地址，点开你的仓库就可以看到你仓库的地址啦。） 首先将你想上传的代码文件夹拖至这个新出现的仓库文件夹，然后命令行输入：cd 你的仓库文件夹名称接下来输入：git add 你想上传的代码文件夹名称或者是输入：git add.(add后面的.表示上传仓库中的所有内容）然后输入：git commit -m &quot;你想交代的内容&quot;最后输入：git push origin master过一小会就能在github的仓库中看到你上传的代码文件夹了。]]></content>
      <categories>
        <category>Github</category>
      </categories>
      <tags>
        <tag>Github</tag>
        <tag>Mac</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo+GitHub博客搭建实战]]></title>
    <url>%2F2018%2F05%2F13%2FHexo-GitHub%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E5%AE%9E%E6%88%98%2F</url>
    <content type="text"><![CDATA[Github的注册大家点击https://github.com/按要求注册即可。 username一定要起一个好听的名字，这在创建博客域名的时候会用到 搭建环境 安装Node.js:https://nodejs.org/en/windows下点击链接，下载安装（下一步下一步下一步…) 安装Git:https://github.com/waylau/git-for-win同上windows下点击上述链接安装即可，不知道Git和Node.js的小伙伴也不要紧，就先知道是必须要有的环境就好。 安装完成后，在开始菜单里找到“Git“-&gt;”Git Bash“,按下图设置，名字和邮箱是Github上的。 安装hexonpm install -g hexo-cli至此本地环境已经搭建完成，下一步开始配置Github 配置Github 登录你刚才注册的Github帐号 点击Create a new repository如下图所示：其中仓库名称Respository name只能填写为，注意！！！是只能填写为你注册的用户名.github.io其他的一概不行！！！仓库创建完成后，开始生成添加秘钥。在终端下输入ssh-keygen -t rsa -C &quot;Github的注册邮箱地址&quot;一路一直按Enter过来就行，待秘钥生成完毕后会得到两个文件id_rsa和id_rsa.pub，用任意文本编辑器打开id_rsa.pub，全选里面的内容复制，然后进入https://github.com/settings/ssh将复制的内容粘贴到Key的输入框，Title里的内容可以随意填写，点击Add SSH key按钮即可。 初始化博客 在电脑里随便一个盘内，新建文件夹test,进入test,按住Shift键点击鼠标右键，点击此处打开命令窗口:输入：hexo init blog稍等片刻，待最后出现成功提示： INFO Start blogging with Hexo! 由于初始化hexo后source目录下自带一篇hello world文章，所以直接输入下面的命令 hexo generate hexo server 在浏览器输入 http://localhost:4000/就可以看见你的博客了 别激动这只是把网站部署到本地，别人看不见，下面我们把网站部署到Github上。 配置博客在blog目录下，用文本编辑器打开_config.yml文件，下面我们来修改参数信息 提示，修改的时候在每个参数的:后面都需要有一个空格,这里没写的先不要修改。 修改网站相关信息123456title: xxx的博客subtitle: 个性签名description: 网页描述author：作者language: zh-CNtimezone: Asia/Shanghai 配置部署1234deploy: type: git repo: https://github.com/你的用户名/你的用户名.github.io branch: master 配置统一资源定位url: https://你的用户名.github.io 发表文章 在命令行中输入hexo new &quot;我的测试文章&quot; 按提示路径找到该文章，打开后可使用Markdown语法编辑文章 接着在blog目录下，输入如下三个命令 hexo clean hexo generate hexo server(此时已经可以在本地浏览了，第4步可发送到远程） hexo deploy正常情况下会跳出Github登录，直接登录即可 若无错误，在浏览器输入博客地址：你的用户名.github.io，就可以看到内容了。]]></content>
      <categories>
        <category>个人博客搭建</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>Github</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySelf]]></title>
    <url>%2F2018%2F05%2F13%2FMySelf%2F</url>
    <content type="text"><![CDATA[联系方式 微信号：pyy19980724 邮箱：849200701@qq.com 手机号：无 个人信息 本科／大连大学计算机系软件工程专业 现阶段学历：本科大二在读 技术博客：https://atooms.github.io Github：https://github.com/ATOOMs 期望职位：Java开发工程师 期望城市：大连，沈阳 工作经历 待更新 开源项目和作品 待更新 技术文章 待更新 技能清单 待更新 致谢感谢您花时间阅读我的简历，期待能有机会和您共事。]]></content>
      <tags>
        <tag>个人简历</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2018%2F05%2F12%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
